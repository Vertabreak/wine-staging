From 800d1ba0a89f1344bd13ef1a078764c8eba28296 Mon Sep 17 00:00:00 2001
From: Steve Lhomme <robux4@ycbcr.xyz>
Date: Thu, 7 Jan 2021 14:28:21 +0100
Subject: [PATCH] widl: Precompute qualified type names, and use them for C++
 interfaces.

This is what MIDL does and avoid mismatching and even fixes some compiling issues.
---
 tools/widl/header.c    |  8 +++-----
 tools/widl/parser.y    |  6 ++++++
 tools/widl/typetree.c  | 16 ++++++++++++++++
 tools/widl/typetree.h  |  1 +
 tools/widl/widltypes.h |  1 +
 5 files changed, 27 insertions(+), 5 deletions(-)

diff --git a/tools/widl/header.c b/tools/widl/header.c
index 5130d82a774..60f0cd96fce 100644
--- a/tools/widl/header.c
+++ b/tools/widl/header.c
@@ -137,15 +137,13 @@ static void write_guid(FILE *f, const char *guid_prefix, const char *name, const
 
 static void write_uuid_decl(FILE *f, type_t *type, const UUID *uuid)
 {
-  char *name = format_namespace(type->namespace, "", "::", type->name, use_abi_namespace ? "ABI" : NULL);
   fprintf(f, "#ifdef __CRT_UUID_DECL\n");
   fprintf(f, "__CRT_UUID_DECL(%s, 0x%08x, 0x%04x, 0x%04x, 0x%02x,0x%02x, 0x%02x,"
         "0x%02x,0x%02x,0x%02x,0x%02x,0x%02x)\n",
-        name, uuid->Data1, uuid->Data2, uuid->Data3, uuid->Data4[0], uuid->Data4[1],
+        type->qualified_name, uuid->Data1, uuid->Data2, uuid->Data3, uuid->Data4[0], uuid->Data4[1],
         uuid->Data4[2], uuid->Data4[3], uuid->Data4[4], uuid->Data4[5], uuid->Data4[6],
         uuid->Data4[7]);
   fprintf(f, "#endif\n");
-  free(name);
 }
 
 static const char *uuid_string(const UUID *uuid)
@@ -467,13 +465,13 @@ void write_type_left(FILE *h, const decl_spec_t *ds, enum name_type name_type, i
       case TYPE_INTERFACE:
       case TYPE_MODULE:
       case TYPE_COCLASS:
-        fprintf(h, "%s", name);
+        fprintf(h, "%s", type_get_qualified_name(t, name_type));
         break;
       case TYPE_RUNTIMECLASS:
         fprintf(h, "%s", type_get_name(type_runtimeclass_get_default_iface(t), name_type));
         break;
       case TYPE_DELEGATE:
-        fprintf(h, "%s", type_get_name(type_delegate_get_iface(t), name_type));
+        fprintf(h, "%s", type_get_qualified_name(type_delegate_get_iface(t), name_type));
         break;
       case TYPE_VOID:
         fprintf(h, "void");
diff --git a/tools/widl/parser.y b/tools/widl/parser.y
index 12be073c01a..35b6ca74cf2 100644
--- a/tools/widl/parser.y
+++ b/tools/widl/parser.y
@@ -2158,9 +2158,15 @@ type_t *reg_type(type_t *type, const char *name, struct namespace *namespace, in
   nt = xmalloc(sizeof(struct rtype));
   nt->name = name;
   if (is_global_namespace(namespace))
+  {
     type->c_name = name;
+    type->qualified_name = name;
+  }
   else
+  {
     type->c_name = format_namespace(namespace, "__x_", "_C", name, use_abi_namespace ? "ABI" : NULL);
+    type->qualified_name = format_namespace(namespace, "", "::", name, use_abi_namespace ? "ABI" : NULL);
+  }
   nt->type = type;
   nt->t = t;
   nt->next = namespace->type_hash[hash];
diff --git a/tools/widl/typetree.c b/tools/widl/typetree.c
index a6fc2b79857..b4dac8b5f70 100644
--- a/tools/widl/typetree.c
+++ b/tools/widl/typetree.c
@@ -52,6 +52,7 @@ type_t *make_type(enum type_type type)
     t->c_name = NULL;
     t->signature = NULL;
     t->short_name = NULL;
+    t->qualified_name = NULL;
     memset(&t->details, 0, sizeof(t->details));
     t->typestring_offset = 0;
     t->ptrdesc = 0;
@@ -92,6 +93,20 @@ const char *type_get_name(const type_t *type, enum name_type name_type)
     return NULL;
 }
 
+const char *type_get_qualified_name(const type_t *type, enum name_type name_type)
+{
+    assert(!!type->c_name == !!type->qualified_name);
+    switch(name_type) {
+    case NAME_DEFAULT:
+        return type->qualified_name;
+    case NAME_C:
+        return type->c_name;
+    }
+
+    assert(0);
+    return NULL;
+}
+
 static size_t append_namespace(char **buf, size_t *len, size_t pos, struct namespace *namespace, const char *separator, const char *abi_prefix)
 {
     int nested = namespace && !is_global_namespace(namespace);
@@ -684,6 +699,7 @@ static void compute_delegate_iface_names(type_t *delegate, type_t *type, type_li
     iface->name = strmake("I%s", delegate->name);
     if (type) iface->c_name = format_parameterized_type_c_name(type, params, "I");
     else iface->c_name = format_namespace(delegate->namespace, "__x_", "_C", iface->name, use_abi_namespace ? "ABI" : NULL);
+    iface->qualified_name = format_namespace(delegate->namespace, "", "::", iface->name, use_abi_namespace ? "ABI" : NULL);
 }
 
 static void compute_interface_signature_uuid(type_t *iface)
diff --git a/tools/widl/typetree.h b/tools/widl/typetree.h
index eefd79f139d..b48c794c125 100644
--- a/tools/widl/typetree.h
+++ b/tools/widl/typetree.h
@@ -61,6 +61,7 @@ type_t *type_coclass_define(type_t *coclass, ifref_list_t *ifaces);
 type_t *type_runtimeclass_define(type_t *runtimeclass, ifref_list_t *ifaces);
 int type_is_equal(const type_t *type1, const type_t *type2);
 const char *type_get_name(const type_t *type, enum name_type name_type);
+const char *type_get_qualified_name(const type_t *type, enum name_type name_type);
 char *gen_name(void);
 extern int is_attr(const attr_list_t *list, enum attr_type t);
 
diff --git a/tools/widl/widltypes.h b/tools/widl/widltypes.h
index 21598a9213d..6aeeac228b6 100644
--- a/tools/widl/widltypes.h
+++ b/tools/widl/widltypes.h
@@ -505,6 +505,7 @@ struct _type_t {
   const char *c_name;
   const char *signature;
   const char *short_name;
+  const char *qualified_name;
   unsigned int typestring_offset;
   unsigned int ptrdesc;           /* used for complex structs */
   int typelib_idx;
-- 
2.29.2

